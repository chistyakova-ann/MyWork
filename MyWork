%scaner_name Lexer
%codes_type lexem_code

%codes
id

%ident_name Id
%token_fields
"usigned __int128 int_val; __float128 float_val;"
%class_members
"unsigned __int128 int_part; __float128 frac_part; ssize_t power; ssize_t sign;bool is_float"
%codes
String, If,         Float,
Else,   Var,        Int,
Bool,   Char,       Void,
Array,  True,       False,
Proto,  Func,       Const,
Elif,   Endif,      For,
In,     While,      Repeat,
Until,  Exit,       Continue,
Return, Read,       Print,
Kw_bool,Kw_string,  Kw_float,
Kw_int,	Kw_char,    Kw_void,


Equal,             Plus,               Minus,
Mul,               Div,                Mod,
LT,                GT,                 LEQ,
GEQ,               Nequal,             FDiv,
Lor,               LNor,               LNot,
LAnd,              LNand,              LXor,
LNXor,             Bor,                BNor,
BXor,              BNXor,              BAnd,
BNAnd,             LShift,             RShift,
BNot,              Pow,                FPow,
Assign,            Open_body_func,     close_body_func,
Open_list_of_names,Close_list_of_names,cond_op,
after_label,       Open_list_of_expr,  Close_list_of_expr,
Semicolon,         Comma,              Dim_size,
Colon

%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}


%keywords
"if" : If, "else" : Else, "int" : Kw_int, "var": Var, "float" : Kw_float,"bool":Kw_bool,
"char" : Kw_char, "string" :Kw_string, "void" : Kw_void, "array" : Array, "true": True,
"false": False,"proto": Proto,"func": Func, "const": Const, "elif": Elif, "endif": Endif,
"for": For,"in": In,"while": While, "repeat": Repeat, "until": Until, "exit": Exit,
"continue": Continue, "return": Return, "read": Read, "print":Print

%delimiters
"=" : Equal, "+" : Plus, "-" : Minus, "*" : Mul, "/" : Div, "%": Mod,"<": LT, ">":GT, 
"<=": LEQ, ">=":GEQ, "!=":Nequal,"/.": FDiv, "||": Lor,"!||": LNor, "!":LNot, "&&": LAnd, 
"!&&": LNAnd, "^^": LXor,"!^^": LNXor,"^":BXor,"~^":BNXor,"|":Bor, "~|":BNor,"&":BAnd, 
"~&":BNAnd, "<<":LShift,">>":RShift,"~":BNot, "**":Pow, "**.":FPow,":=":Assign, 
"{":Open_body_func,"}":close_body_func, "(":Open_list_of_names, ")":Close_list_of_names,"#":Dim_size, "?":cond_op,";":Semicolon,",":Comma,"::":after_label,"[":Open_list_of_expr,"]":Close_list_of_expr,
":":Colon

%strings "buffer.clean();":"token.code=(buffer.length()==1)?Char:String;"
{"([:ndq:]$write|""$write)*"}   


%numbers  "int_part= 0;frac_part=1; token.code = Number;" : "token.int_val = int_part;"

  %action addDecDigit "frac_part=frac_part*10+digit2int(ch)"

  %action addHexDigit "int_part = (int_part << 4) + digitToInt(ch);"
  %action addDecDigit "int_part = int_part * 10 + digitToInt(ch);"
  %action addBinDigit "int_part = (int_part<< 1) + digitToInt(ch);"
  %action addOctDigit "int_part = (int_part<< 3) + digitToInt(ch);"
  {0(x|X)[:xdigits:]$addHexDigit+ | [:digits:]$addDecDigit+ |0(b|B)[:bdigits:]$addBinDigit+|0(o|O)[:odigits:]$addOctDigit+}|
{[:digits:](?[digits:])*(.[:digits:]+((E|e)(+|-)?[:digits]+)?)}
 
